[{"/Users/momocloud/Files/RMIT/BIT/app1/Machine-Learning-React-F/src/index.js":"1","/Users/momocloud/Files/RMIT/BIT/app1/Machine-Learning-React-F/src/App.js":"2","/Users/momocloud/Files/RMIT/BIT/app1/Machine-Learning-React-F/src/components/Home/Home.js":"3","/Users/momocloud/Files/RMIT/BIT/app1/Machine-Learning-React-F/src/components/Common/ScrollToTop.js":"4","/Users/momocloud/Files/RMIT/BIT/app1/Machine-Learning-React-F/src/components/Algorithm/Types/ObjectDetectionAlgorithm.js":"5","/Users/momocloud/Files/RMIT/BIT/app1/Machine-Learning-React-F/src/components/Algorithm/Types/KNearestNeighborAlgorithm.js":"6","/Users/momocloud/Files/RMIT/BIT/app1/Machine-Learning-React-F/src/components/Algorithm/Types/NeuralNetworkAlgorithm.js":"7","/Users/momocloud/Files/RMIT/BIT/app1/Machine-Learning-React-F/src/components/Algorithm/Types/KMeanAlgorithm.js":"8","/Users/momocloud/Files/RMIT/BIT/app1/Machine-Learning-React-F/src/components/Algorithm/Types/LogisticRegression/LogisticRegressionAlgorithm.js":"9","/Users/momocloud/Files/RMIT/BIT/app1/Machine-Learning-React-F/src/components/Algorithm/Types/LinearRegression/LinearRegressionAlgorithm.js":"10","/Users/momocloud/Files/RMIT/BIT/app1/Machine-Learning-React-F/src/components/Home/Menu.js":"11","/Users/momocloud/Files/RMIT/BIT/app1/Machine-Learning-React-F/src/components/Home/FirstSegment/Navbar.js":"12","/Users/momocloud/Files/RMIT/BIT/app1/Machine-Learning-React-F/src/components/Home/FirstSegment/Veil.js":"13","/Users/momocloud/Files/RMIT/BIT/app1/Machine-Learning-React-F/src/components/Home/SecondSegment/Algorithms.js":"14","/Users/momocloud/Files/RMIT/BIT/app1/Machine-Learning-React-F/src/components/Home/FourthSegment/AboutUs.js":"15","/Users/momocloud/Files/RMIT/BIT/app1/Machine-Learning-React-F/src/components/Home/ThirdSegment/PoweredBy.js":"16","/Users/momocloud/Files/RMIT/BIT/app1/Machine-Learning-React-F/src/components/Algorithm/Panel/LeftPanel.js":"17","/Users/momocloud/Files/RMIT/BIT/app1/Machine-Learning-React-F/src/components/Algorithm/Panel/PanelChild.js":"18","/Users/momocloud/Files/RMIT/BIT/app1/Machine-Learning-React-F/src/components/Algorithm/Panel/RightPanel.js":"19","/Users/momocloud/Files/RMIT/BIT/app1/Machine-Learning-React-F/src/components/Algorithm/Panel/PanelSection.js":"20","/Users/momocloud/Files/RMIT/BIT/app1/Machine-Learning-React-F/src/components/Algorithm/Sketches/neuralnetwork/NeuralNetwork.js":"21","/Users/momocloud/Files/RMIT/BIT/app1/Machine-Learning-React-F/src/components/Algorithm/Sketches/objectdetection/ObjectDetection.js":"22","/Users/momocloud/Files/RMIT/BIT/app1/Machine-Learning-React-F/src/components/Algorithm/Sketches/kmeanclustering/Clustering.js":"23","/Users/momocloud/Files/RMIT/BIT/app1/Machine-Learning-React-F/src/components/Algorithm/Sketches/linearregression/Wrapper.js":"24","/Users/momocloud/Files/RMIT/BIT/app1/Machine-Learning-React-F/src/components/Algorithm/Sketches/logisticregression/LositicRegression.js":"25","/Users/momocloud/Files/RMIT/BIT/app1/Machine-Learning-React-F/src/components/Algorithm/Sketches/nearestneighbors/NearestNeighbor.js":"26","/Users/momocloud/Files/RMIT/BIT/app1/Machine-Learning-React-F/src/components/Home/ThirdSegment/ConvNetCard.js":"27","/Users/momocloud/Files/RMIT/BIT/app1/Machine-Learning-React-F/src/components/Home/ThirdSegment/P5Card.js":"28","/Users/momocloud/Files/RMIT/BIT/app1/Machine-Learning-React-F/src/components/Home/ThirdSegment/TensorflowCard.js":"29","/Users/momocloud/Files/RMIT/BIT/app1/Machine-Learning-React-F/src/components/Home/SecondSegment/AlgorithmCarousel.js":"30","/Users/momocloud/Files/RMIT/BIT/app1/Machine-Learning-React-F/src/components/Algorithm/Sketches/neuralnetwork/ControlPanel.js":"31","/Users/momocloud/Files/RMIT/BIT/app1/Machine-Learning-React-F/src/components/Algorithm/Sketches/kmeanclustering/cluster.js":"32","/Users/momocloud/Files/RMIT/BIT/app1/Machine-Learning-React-F/src/components/Algorithm/Sketches/logisticregression/Model.js":"33","/Users/momocloud/Files/RMIT/BIT/app1/Machine-Learning-React-F/src/components/Algorithm/Sketches/logisticregression/ControlPanel.js":"34","/Users/momocloud/Files/RMIT/BIT/app1/Machine-Learning-React-F/src/components/Algorithm/Sketches/linearregression/LinearRegression.js":"35","/Users/momocloud/Files/RMIT/BIT/app1/Machine-Learning-React-F/src/components/Algorithm/Sketches/nearestneighbors/point.js":"36","/Users/momocloud/Files/RMIT/BIT/app1/Machine-Learning-React-F/src/components/Algorithm/Sketches/nearestneighbors/ControlPanel.js":"37","/Users/momocloud/Files/RMIT/BIT/app1/Machine-Learning-React-F/src/components/Algorithm/Sketches/neuralnetwork/Model.js":"38","/Users/momocloud/Files/RMIT/BIT/app1/Machine-Learning-React-F/src/components/Algorithm/Sketches/kmeanclustering/ControlPanel.js":"39","/Users/momocloud/Files/RMIT/BIT/app1/Machine-Learning-React-F/src/components/Algorithm/Sketches/common/point.js":"40","/Users/momocloud/Files/RMIT/BIT/app1/Machine-Learning-React-F/src/components/Home/SecondSegment/LogisticRegressionCard.js":"41","/Users/momocloud/Files/RMIT/BIT/app1/Machine-Learning-React-F/src/components/Home/SecondSegment/LinearRegressionCard.js":"42","/Users/momocloud/Files/RMIT/BIT/app1/Machine-Learning-React-F/src/components/Home/SecondSegment/NeuralNetworkCard.js":"43","/Users/momocloud/Files/RMIT/BIT/app1/Machine-Learning-React-F/src/components/Home/SecondSegment/ObjectDetectionCard.js":"44","/Users/momocloud/Files/RMIT/BIT/app1/Machine-Learning-React-F/src/components/Home/SecondSegment/KMeanCard.js":"45","/Users/momocloud/Files/RMIT/BIT/app1/Machine-Learning-React-F/src/components/Home/SecondSegment/KNearestNeighborsCard.js":"46","/Users/momocloud/Files/RMIT/BIT/app1/Machine-Learning-React-F/src/components/Algorithm/Sketches/neuralnetwork/StartStopButton.js":"47","/Users/momocloud/Files/RMIT/BIT/app1/Machine-Learning-React-F/src/components/Algorithm/Sketches/linearregression/Model.js":"48","/Users/momocloud/Files/RMIT/BIT/app1/Machine-Learning-React-F/src/components/Home/FirstSegment/Sketch.js":"49"},{"size":416,"mtime":1609771137934,"results":"50","hashOfConfig":"51"},{"size":1805,"mtime":1609659278693,"results":"52","hashOfConfig":"51"},{"size":1909,"mtime":1609739085733,"results":"53","hashOfConfig":"51"},{"size":381,"mtime":1609659278699,"results":"54","hashOfConfig":"51"},{"size":3507,"mtime":1609659278699,"results":"55","hashOfConfig":"51"},{"size":3484,"mtime":1609659278697,"results":"56","hashOfConfig":"51"},{"size":3493,"mtime":1609659278699,"results":"57","hashOfConfig":"51"},{"size":3446,"mtime":1609659278697,"results":"58","hashOfConfig":"51"},{"size":8504,"mtime":1609659278698,"results":"59","hashOfConfig":"51"},{"size":6900,"mtime":1609659278697,"results":"60","hashOfConfig":"51"},{"size":1322,"mtime":1609659278700,"results":"61","hashOfConfig":"51"},{"size":348,"mtime":1609738778030,"results":"62","hashOfConfig":"51"},{"size":657,"mtime":1609766417044,"results":"63","hashOfConfig":"51"},{"size":386,"mtime":1609766135338,"results":"64","hashOfConfig":"51"},{"size":3927,"mtime":1609773072086,"results":"65","hashOfConfig":"51"},{"size":2957,"mtime":1609770448384,"results":"66","hashOfConfig":"51"},{"size":739,"mtime":1609659278694,"results":"67","hashOfConfig":"51"},{"size":927,"mtime":1609659278694,"results":"68","hashOfConfig":"51"},{"size":1134,"mtime":1609659278694,"results":"69","hashOfConfig":"51"},{"size":799,"mtime":1609659278694,"results":"70","hashOfConfig":"51"},{"size":6927,"mtime":1609659278696,"results":"71","hashOfConfig":"51"},{"size":3071,"mtime":1609659278697,"results":"72","hashOfConfig":"51"},{"size":7829,"mtime":1609659278694,"results":"73","hashOfConfig":"51"},{"size":168,"mtime":1609659278695,"results":"74","hashOfConfig":"51"},{"size":6602,"mtime":1609659278695,"results":"75","hashOfConfig":"51"},{"size":8503,"mtime":1609659278696,"results":"76","hashOfConfig":"51"},{"size":641,"mtime":1609773263765,"results":"77","hashOfConfig":"51"},{"size":564,"mtime":1609773220102,"results":"78","hashOfConfig":"51"},{"size":644,"mtime":1609767468609,"results":"79","hashOfConfig":"51"},{"size":1477,"mtime":1609759090100,"results":"80","hashOfConfig":"51"},{"size":1665,"mtime":1609659278696,"results":"81","hashOfConfig":"51"},{"size":467,"mtime":1609659278695,"results":"82","hashOfConfig":"51"},{"size":1676,"mtime":1609659278696,"results":"83","hashOfConfig":"51"},{"size":1145,"mtime":1609659278695,"results":"84","hashOfConfig":"51"},{"size":4941,"mtime":1609659278695,"results":"85","hashOfConfig":"51"},{"size":583,"mtime":1609659278696,"results":"86","hashOfConfig":"51"},{"size":1725,"mtime":1609659278696,"results":"87","hashOfConfig":"51"},{"size":1873,"mtime":1609659278696,"results":"88","hashOfConfig":"51"},{"size":510,"mtime":1609659278695,"results":"89","hashOfConfig":"51"},{"size":132,"mtime":1609659278694,"results":"90","hashOfConfig":"51"},{"size":798,"mtime":1609773627293,"results":"91","hashOfConfig":"51"},{"size":781,"mtime":1609773651717,"results":"92","hashOfConfig":"51"},{"size":775,"mtime":1609773641598,"results":"93","hashOfConfig":"51"},{"size":772,"mtime":1609773645902,"results":"94","hashOfConfig":"51"},{"size":734,"mtime":1609773662065,"results":"95","hashOfConfig":"51"},{"size":791,"mtime":1609773657217,"results":"96","hashOfConfig":"51"},{"size":721,"mtime":1609659278697,"results":"97","hashOfConfig":"51"},{"size":1156,"mtime":1609659278695,"results":"98","hashOfConfig":"51"},{"size":2969,"mtime":1609725566089,"results":"99","hashOfConfig":"51"},{"filePath":"100","messages":"101","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"1a2ioze",{"filePath":"102","messages":"103","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"104","usedDeprecatedRules":"105"},{"filePath":"106","messages":"107","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"108","usedDeprecatedRules":"105"},{"filePath":"109","messages":"110","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"111","usedDeprecatedRules":"105"},{"filePath":"112","messages":"113","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"105"},{"filePath":"114","messages":"115","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"105"},{"filePath":"116","messages":"117","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"105"},{"filePath":"118","messages":"119","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"105"},{"filePath":"120","messages":"121","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"105"},{"filePath":"122","messages":"123","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"105"},{"filePath":"124","messages":"125","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"105"},{"filePath":"126","messages":"127","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"128","usedDeprecatedRules":"105"},{"filePath":"129","messages":"130","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"105"},{"filePath":"131","messages":"132","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"105"},{"filePath":"133","messages":"134","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"135","messages":"136","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"137","messages":"138","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"105"},{"filePath":"139","messages":"140","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"141","usedDeprecatedRules":"105"},{"filePath":"142","messages":"143","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"105"},{"filePath":"144","messages":"145","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"105"},{"filePath":"146","messages":"147","errorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"148","usedDeprecatedRules":"105"},{"filePath":"149","messages":"150","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"105"},{"filePath":"151","messages":"152","errorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"153","usedDeprecatedRules":"105"},{"filePath":"154","messages":"155","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"156","usedDeprecatedRules":"105"},{"filePath":"157","messages":"158","errorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"159","usedDeprecatedRules":"105"},{"filePath":"160","messages":"161","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"162","usedDeprecatedRules":"105"},{"filePath":"163","messages":"164","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"165","messages":"166","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"167","messages":"168","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"105"},{"filePath":"169","messages":"170","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"105"},{"filePath":"171","messages":"172","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"173","usedDeprecatedRules":"105"},{"filePath":"174","messages":"175","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"105"},{"filePath":"176","messages":"177","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"178","usedDeprecatedRules":"105"},{"filePath":"179","messages":"180","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"181","usedDeprecatedRules":"105"},{"filePath":"182","messages":"183","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"184","usedDeprecatedRules":"105"},{"filePath":"185","messages":"186","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"105"},{"filePath":"187","messages":"188","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"189","usedDeprecatedRules":"105"},{"filePath":"190","messages":"191","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"192","usedDeprecatedRules":"105"},{"filePath":"193","messages":"194","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"195","usedDeprecatedRules":"105"},{"filePath":"196","messages":"197","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"105"},{"filePath":"198","messages":"199","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"200","messages":"201","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"202","messages":"203","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"204","messages":"205","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"206","messages":"207","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"208","messages":"209","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"210","messages":"211","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"105"},{"filePath":"212","messages":"213","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"105"},{"filePath":"214","messages":"215","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"105"},"/Users/momocloud/Files/RMIT/BIT/app1/Machine-Learning-React-F/src/index.js",[],"/Users/momocloud/Files/RMIT/BIT/app1/Machine-Learning-React-F/src/App.js",["216"],"import './App.css';\nimport Home from './components/Home/Home';\n\n//using react-router\nimport {\n  BrowserRouter,\n  Switch,\n  Route,\n  Link\n} from \"react-router-dom\";\n\n//import types from Algorithm\nimport RegressionAlgorithm from \"./components/Algorithm/Types/LinearRegression/LinearRegressionAlgorithm\";\nimport LogisiticAlgorithm from \"./components/Algorithm/Types/LogisticRegression/LogisticRegressionAlgorithm\";\nimport NeuralNetworkAlgorithm from \"./components/Algorithm/Types/NeuralNetworkAlgorithm\";\nimport KMeanClusteringAlgorithm from \"./components/Algorithm/Types/KMeanAlgorithm\";\nimport KNearestNeighborAlgorithm from \"./components/Algorithm/Types/KNearestNeighborAlgorithm\";\nimport ObjectDetectionAlgorithm from \"./components/Algorithm/Types/ObjectDetectionAlgorithm\";\n\n//import component for scrolling control\nimport ScrollToTop from \"./components/Common/ScrollToTop\";\n\nfunction App() {\n  return (\n    <div className=\"App\">\n        <BrowserRouter>\n            <ScrollToTop/>\n            <Switch>\n              <Route exact path=\"/\">\n                <Home />\n              </Route>\n\n              <Route path=\"/chapter1\">\n                <RegressionAlgorithm />\n              </Route>\n\n              <Route path=\"/chapter2\">\n              <LogisiticAlgorithm />\n              </Route>\n\n              <Route path=\"/chapter3\">\n                <NeuralNetworkAlgorithm/>\n              </Route>\n\n              <Route path=\"/chapter4\">\n                <ObjectDetectionAlgorithm/>\n              </Route>\n\n              <Route path=\"/chapter5\">\n                <KNearestNeighborAlgorithm/>\n              </Route>\n\n              <Route path=\"/chapter6\">\n                <KMeanClusteringAlgorithm/>\n              </Route>\n            </Switch>\n        </BrowserRouter>\n    </div>\n  );\n}\n\nexport default App;\n",["217","218"],"/Users/momocloud/Files/RMIT/BIT/app1/Machine-Learning-React-F/src/components/Home/Home.js",["219","220","221"],"import {Component, useRef} from \"react\";\nimport React from \"react\";\nimport Navbar from \"./FirstSegment/Navbar\";\nimport Veil from \"./FirstSegment/Veil\";\nimport Algorithms from \"./SecondSegment/Algorithms\";\nimport PoweredBy from \"./ThirdSegment/PoweredBy\";\nimport AboutUs from \"./FourthSegment/AboutUs\";\nimport Sketch from \"./FirstSegment/Sketch\";\n\nclass Home extends Component {\n    constructor(props){\n        super(props);\n        this.myRef = React.createRef();\n        this.SmoothVerticalScrolling = this.SmoothVerticalScrolling.bind(this);\n    }\n\n    //smooth scrolling\n     SmoothVerticalScrolling(){\n         this.myRef.current.scrollIntoView({\n            behavior: 'smooth',\n            block: 'start'\n         });\n     }\n\n    render(){\n        {/*Name of the classes are snap-etc as snap effects are intended for usage*/}\n        return(\n            <div className=\"snap-container\">\n                <section style={{position: \"fixed\", zIndex: -100}}>\n                    <Sketch/> {/*star animation*/}\n                </section>\n                {/*first segment*/}\n                <section className=\"snap-child\">\n                    <Veil smoothScroll={this.SmoothVerticalScrolling}/> {/*introduction panel component - status - in production*/}\n                </section>\n\n                {/*second segment*/}\n                <section className=\"snap-child\" ref={this.myRef}>\n                    <Algorithms /> {/*the algorithm carousel component - status - in production*/}\n                </section>\n\n                {/*third segment*/}\n                <section className=\"snap-child\" id=\"powered-by-section\">\n                    <PoweredBy/>\n                </section>\n\n                {/*fourth segment*/}\n                <section className=\"snap-child\" id=\"about-us-section\">\n                    <AboutUs/>\n                </section>\n\n            </div>\n        );\n    }\n}\n\nexport default Home;","/Users/momocloud/Files/RMIT/BIT/app1/Machine-Learning-React-F/src/components/Common/ScrollToTop.js",["222"],"import React, {Component} from \"react\";\nimport {withRouter} from \"react-router-dom\";\n\nclass ScrollToTop extends Component{\n    componentDidUpdate(){\n        this.scrollToTop();\n    }\n\n    scrollToTop(){\n        window.scrollTo({\n            top: 0,\n            behavior:\"smooth\"\n        });\n    }\n\n    render(){\n        return null;\n    }\n}\n\nexport default withRouter(ScrollToTop);","/Users/momocloud/Files/RMIT/BIT/app1/Machine-Learning-React-F/src/components/Algorithm/Types/ObjectDetectionAlgorithm.js",[],"/Users/momocloud/Files/RMIT/BIT/app1/Machine-Learning-React-F/src/components/Algorithm/Types/KNearestNeighborAlgorithm.js",[],"/Users/momocloud/Files/RMIT/BIT/app1/Machine-Learning-React-F/src/components/Algorithm/Types/NeuralNetworkAlgorithm.js",[],"/Users/momocloud/Files/RMIT/BIT/app1/Machine-Learning-React-F/src/components/Algorithm/Types/KMeanAlgorithm.js",[],"/Users/momocloud/Files/RMIT/BIT/app1/Machine-Learning-React-F/src/components/Algorithm/Types/LogisticRegression/LogisticRegressionAlgorithm.js",[],"/Users/momocloud/Files/RMIT/BIT/app1/Machine-Learning-React-F/src/components/Algorithm/Types/LinearRegression/LinearRegressionAlgorithm.js",[],"/Users/momocloud/Files/RMIT/BIT/app1/Machine-Learning-React-F/src/components/Home/Menu.js",[],"/Users/momocloud/Files/RMIT/BIT/app1/Machine-Learning-React-F/src/components/Home/FirstSegment/Navbar.js",["223","224"],"import Menu from \"../Menu.js\";\nimport logo from \"../../../images/logo.jpg\";\n\n//Link router\nimport {Link} from \"react-router-dom\";\n\nconst Navbar = (props) => {\n    return(\n        <nav className=\"navbar\" style={\n            {\n                height: \"10%\"\n            }\n        }>\n            <Menu />\n        </nav>\n    );\n}\n\nexport default Navbar;","/Users/momocloud/Files/RMIT/BIT/app1/Machine-Learning-React-F/src/components/Home/FirstSegment/Veil.js",[],"/Users/momocloud/Files/RMIT/BIT/app1/Machine-Learning-React-F/src/components/Home/SecondSegment/Algorithms.js",[],"/Users/momocloud/Files/RMIT/BIT/app1/Machine-Learning-React-F/src/components/Home/FourthSegment/AboutUs.js",[],"/Users/momocloud/Files/RMIT/BIT/app1/Machine-Learning-React-F/src/components/Home/ThirdSegment/PoweredBy.js",[],"/Users/momocloud/Files/RMIT/BIT/app1/Machine-Learning-React-F/src/components/Algorithm/Panel/LeftPanel.js",[],"/Users/momocloud/Files/RMIT/BIT/app1/Machine-Learning-React-F/src/components/Algorithm/Panel/PanelChild.js",["225"],"import React from 'react';\nimport Panel from './PanelSection';\n\nclass PanelChild extends React.Component {\n    isBottom(el) {\n        return el.getBoundingClientRect().bottom <= window.innerHeight + 10;\n    }\n\n    componentDidMount() {\n        document\n            .addEventListener('scroll', this.trackScrolling);\n    }\n\n    componentWillUnmount() {\n        document\n            .removeEventListener('scroll', this.trackScrolling);\n    }\n\n    trackScrolling = () => {\n        const wrappedElement = document.getElementById(\"algo-panel-child\" + this.props.index);\n        if (this.isBottom(wrappedElement)) {\n            //Call props\n            this.props.onScrollTo(this.props.index);\n        }\n    };\n\n    render() {\n        return <div className=\"algo-panel-child\" id={\"algo-panel-child\" + this.props.index}>\n            {\n                this.props.children\n            }\n        </div>\n    }\n}\n\nexport default PanelChild;","/Users/momocloud/Files/RMIT/BIT/app1/Machine-Learning-React-F/src/components/Algorithm/Panel/RightPanel.js",[],"/Users/momocloud/Files/RMIT/BIT/app1/Machine-Learning-React-F/src/components/Algorithm/Panel/PanelSection.js",[],"/Users/momocloud/Files/RMIT/BIT/app1/Machine-Learning-React-F/src/components/Algorithm/Sketches/neuralnetwork/NeuralNetwork.js",["226","227","228","229","230"],"import Model from './Model';\nimport Sketch from 'react-p5';\nimport ControlPanel from './ControlPanel';\nimport Point from '../common/point';\n\n//Store state outside -> Need refractoring\n//Initialize a model\nlet model = new Model();\n\n//Current points\nlet points = [];\n\n//Select the type of point you want to use\nlet currentType = 1;\nconst changeType = (type) => {\n    currentType = type;\n}\n\n//Training state -> Check if training has begun\nlet isTraining = false;\nlet hasConverged = false;\n\n//Save losses\nlet losses = [];\n\n//Segments for illusrating the prediction boundary\nconst SEG_SIZE = 10;\nlet segments = [];\n\nexport default (props) => {\n    //Handle user interactions\n    const startTraining = () => {\n        isTraining = true;\n    }\n\n    const stopTraining = () => {\n        isTraining = false;\n    }\n\n    const reset = () => {\n        //Create new model\n        model = new Model();\n        points = [];\n        losses = [];\n        isTraining = false;\n        hasConverged = false;\n    }\n\n    //Initialize segments\n    function createSegments(width, height, p5) {\n        //Initialize segements\n        segments = []; ///Reset\n        for (let r = 0; r != Math.round(width / SEG_SIZE) + 1; r++) {\n            for (let c = 0; c != Math.round(height / SEG_SIZE) + 1; ++c) {\n                //Apppent to segments\n                segments.push([c * SEG_SIZE, r * SEG_SIZE]);\n            }\n        }\n    }\n\n    //Helper function\n    const trainModel = () => {\n        //Make datapoints\n        let data = [];\n        let labels = [];\n        \n        points.forEach(p => {\n            //Add data and label\n            data.push([p.x, p.y]);\n            labels.push(p.type);\n        })\n        \n        //Train model\n        return model.train(data, labels);\n    }\n\n    //Predict segments -> Illustrate\n    const displaySegments = (p5) => {\n        p5.noStroke();\n\n        for (let i = 0; i != segments.length; ++i) {\n            //Get the segment location -> Map back to canvas\n            let x = p5.map(segments[i][0], 0, p5.width, 0, 1);\n            let y = p5.map(segments[i][1], 0, p5.height, 1, 0);\n            \n            //Get prob\n            let prob = model.predict([x, y]);\n        \n            //Draw \n            if (prob > 0.5) {\n              p5.fill('rgba(69, 123, 157, ' + (prob/2).toString() + ')');\n            } else {\n              p5.fill('rgba(244, 162, 97, ' + ((1-prob)/2).toString() +')');\n            }\n\n            p5.rect(segments[i][0], segments[i][1], SEG_SIZE, SEG_SIZE);\n        }\n    }\n\n    //Handle windows resize\n    const windowResize = (p5) => {\n        p5.resizeCanvas(p5.windowWidth / 4, p5.windowWidth / 4);\n        createSegments(p5.windowWidth / 4, p5.windowWidth / 4, p5);\n    }\n\n    //Set up and draw for left canvas\n    const leftSetup = (p5, canvasParentRef) => {\n        //Set canvas size dynamically\n        const width = p5.windowWidth / 4, height = p5.windowWidth / 4;\n        p5.createCanvas(width, height).parent(canvasParentRef);\n\n        //Create segments for illustrating\n        createSegments(width, height, p5);\n    }\n\n    const leftDraw = (p5) => {\n        p5.background(204);\n\n        p5.noStroke();\n\n        points.forEach(p => {\n            //Map canvas coordinates to [0,1]\n            let x = p5.map(p.x, 0, 1, 0, p5.width);\n            let y = p5.map(p.y, 0, 1, p5.height, 0);\n\n            if (p.type == 0) {\n                p5.fill('#F4A261');\n            } else {\n                p5.fill('#457B9D');\n            }\n\n            p5.circle(x, y, 10);\n        });\n\n        //Train model if has started\n        if (isTraining && !hasConverged) {\n            //Append loss\n            let loss = trainModel(p5);\n            losses.push(loss);\n\n            //Check if model has converged\n            if (losses.length >= 2 && Math.abs(losses[losses.length - 1] - losses[losses.length - 2]) <= 0.0001) {\n                hasConverged = true;\n            }\n        }\n\n        //Render predictions\n        if (losses.length > 0) {\n            displaySegments(p5);\n        }\n    }\n\n    const leftMouseClicked = (p5) => {\n        //Check mouse position if inside canvas\n        if (!isTraining && \n            losses.length === 0 &&\n            p5.mouseX > 0 && p5.mouseX <= p5.width && p5.mouseY > 0 && p5.mouseY <= p5.height) {\n            //Map canvas coordinates to [0,1]\n            let x = p5.map(p5.mouseX, 0, p5.width, 0, 1);\n            let y = p5.map(p5.mouseY, 0, p5.height, 1, 0);\n\n            //Create a point based on mouse position and current type\n            let point = new Point(x, y, currentType);\n\n            //Append to list\n            points.push(point);\n        }\n    }\n\n    //Set up and draw for right canvas\n    const rightSetup = (p5, canvasParentRef) => {\n        const width = p5.windowWidth / 4, height = p5.windowWidth / 4;\n        p5.createCanvas(width, height).parent(canvasParentRef);\n\n        //Set font\n        p5.textFont('Raleway');\n    }\n\n    const rightDraw = (p5) => {\n        p5.background(255);\n\n        if (losses.length > 0) {\n            drawLosses(p5);\n        }\n    }\n\n    const drawLosses = (p5) => {\n        //Calculate the current x offset\n        let offset = 40;\n        let offSetChange = (p5.width - offset * 2) / (losses.length);\n\n        //Get the latest loss -> Display\n        p5.textSize(20);\n        p5.fill('#ddbea9');\n        p5.strokeWeight(1);\n        p5.textFont('Raleway');\n        p5.text('Loss: ' + losses[losses.length - 1].toFixed(4).toString(), 40, 20);\n\n        //Check if converge\n        if (hasConverged) {\n            p5.fill('#2a9d8f');\n            p5.noStroke();\n            p5.textFont('Raleway');\n            p5.text('Converged', 40, 40);\n        }\n\n        //Draw line chart showing plots\n        p5.noFill();\n        p5.stroke('#f9dcc4');\n        p5.strokeWeight(3);\n        p5.beginShape();\n\n        losses.forEach((loss) => {\n            //Map the loss\n            let mappedLoss;\n            mappedLoss = p5.map(loss, 0, losses[0], p5.height, p5.width / 2);\n\n            //Draw vertex \n            p5.vertex(offset, mappedLoss);\n            //Increase offset\n            offset += offSetChange;\n        })\n\n        p5.endShape();\n    }\n\n    return <div>\n        <div style={{float: \"left\"}}>\n            <Sketch \n                setup={leftSetup}\n                draw={leftDraw}\n                mouseClicked={leftMouseClicked}\n                windowResized={windowResize}\n                > \n            </Sketch>\n        </div>\n\n        <div style={{float: \"left\"}}>\n            <Sketch \n                setup={rightSetup}\n                draw={rightDraw}\n                windowResized={windowResize}> \n            </Sketch>\n        </div>\n\n        <div style={{clear: \"both\"}}></div>\n\n        <ControlPanel\n            onChangeType={changeType}\n            onStart={startTraining}\n            onStop={stopTraining}\n            onReset={reset}>\n        </ControlPanel>\n    </div>\n}","/Users/momocloud/Files/RMIT/BIT/app1/Machine-Learning-React-F/src/components/Algorithm/Sketches/objectdetection/ObjectDetection.js",[],"/Users/momocloud/Files/RMIT/BIT/app1/Machine-Learning-React-F/src/components/Algorithm/Sketches/kmeanclustering/Clustering.js",["231","232","233","234"],"import Sketch from 'react-p5';\nimport Point from '../common/point';\nimport ClusterCore from './cluster';\nimport ControlPanel from './ControlPanel';\n\n//Save state outside components -> Need rethink\n//Create cores\nlet ORIGINS = [\n    [100, 150],\n    [500, 150],\n    [300, 500]\n];\nlet points = [];\nlet cores;\n\n//Save reference to p5 for math utils\nlet p5Ref;\n\n//Hold points and cores\nlet POINT_RADIUS = 15;\n\n//Sizes\nlet width, height, display;\n\nexport default (props) => {\n    //Function to create cores and cluster\n    const generateCluster = () => {\n        //Clear previous point\n        points = [];\n        \n        //Create points around the core\n        ORIGINS.forEach(core => {\n            //Create 30 points around each core\n            for (let i = 0; i != 30; ++i) {\n                let x = -1;\n                let y = -1;\n\n                while(!(x >= POINT_RADIUS && x <= width - POINT_RADIUS && y >= POINT_RADIUS && y <= height - POINT_RADIUS)) {\n                    x = core[0] + p5Ref.randomGaussian(0, POINT_RADIUS * 2);\n                    y = core[1] + p5Ref.randomGaussian(0, POINT_RADIUS * 2);\n                }\n\n                points.push(new Point(x, y, null));\n            }\n        });\n    }\n\n    const generateCores = () => {\n        //Clear previous cores\n        cores = [];\n        \n        //Create 3 cores\n        for (let i = 0; i != 3; ++i) {\n            //Random core initialization\n            let x = p5Ref.random(10, width - 10);\n            let y = p5Ref.random(10, height - 10);\n            \n            cores.push(new ClusterCore(x, y, i));\n        }\n    }\n\n    const distance = (point, core) => {\n        return p5Ref.sqrt(p5Ref.sq(point.x - core.x) + p5Ref.sq(point.y - core.y));\n    }\n\n    const update = () => {\n        //Clear children first\n        cores.forEach(core => {\n            core.clearChildren();\n        });\n  \n        points.forEach(p => {\n            //For each points -> calculate the distance to three cores\n            let minDistance = Infinity;\n            let minType = null;\n    \n            cores.forEach(core => {\n                //Get the distance\n                let dist = distance(p, core);\n                //Update the potential type\n                if (dist < minDistance) {\n                    minDistance = dist;\n                    minType = core.type;\n                }\n            });\n\n            \n            //Set the potential type to p\n            p.type = minType;\n                \n            //Add to minType child\n            cores[minType].addChild(p);\n        });\n        \n        //Calculate the target position for each core\n        cores.forEach(core => {\n            //Calculate the average of children coordinates\n            let sumX = 0;\n            let sumY = 0;\n            \n            core.children.forEach(p => {\n                sumX += p.x;\n                sumY += p.y;\n            });\n            \n            //Target position is the average\n            if (core.children.length != 0) {\n                let targetX = (sumX + 0.0) / core.children.length;\n                let targetY = (sumY + 0.0) / core.children.length;\n                \n                //Set position\n                core.setTarget(targetX, targetY);\n            }\n        });\n    }\n\n    //Handle user interactions\n    const onGenerateClusters = () => {\n        generateCluster();\n    }\n\n    const onGenerateCores = () => {\n        generateCores();\n    }\n\n    const scalePoints = (ratio) => {\n        points.forEach(point => {\n            point.x = point.x * ratio;\n            point.y = point.y * ratio;\n        });\n    }\n\n    //Handle resize\n    const windowResized = (p5) => {\n        //Get the new size\n        let newWidth = p5.windowWidth / 3;\n        let newHeight = p5.windowWidth / 3;\n        let newDisplay = p5.windowWidth / 6;\n\n        //Get the ratio\n        let ratio = newWidth / width;\n        POINT_RADIUS *= ratio;\n        scalePoints(ratio);\n\n        //Set new sizes\n        width = newWidth;\n        height = newHeight;\n        display = newDisplay\n\n        //Resize the canvas\n        p5.resizeCanvas(width + display, height);\n    }\n\n    //Set up and draw function\n    const setup = (p5, canvasParentRef) => {\n        //Create windows\n        width = p5.windowWidth / 3;\n        height = p5.windowWidth / 3;\n        display = p5.windowWidth / 6;\n\n        p5.createCanvas(width + display, height).parent(canvasParentRef);\n\n        //Save reference to use math functionality only\n        p5Ref = p5;\n\n        //Set font size\n        p5.textFont('Raleway');\n\n        //Set the origin points\n        ORIGINS = [\n            [width * 0.25, width * 0.25],\n            [width * 0.75, width * 0.25],\n            [width * 0.5, width * 0.75]\n        ];\n\n        //Generate cores\n        /*\n        generateCluster();\n        */\n        generateCores();\n    }\n\n    const draw = (p5) => {\n        p5.background(204);\n\n        //Move the cores into position\n        cores.forEach(core => {\n            if (core.target_x != null) {\n                core.setPosition(p5.lerp(core.x, core.target_x, 0.01), p5.lerp(core.y, core.target_y, 0.01));\n            }\n        })\n\n        //Visualize the points\n        p5.stroke('black');\n        points.forEach(p => {\n            p5.strokeWeight(2);\n            if (p.type === 0) {\n                p5.fill('#e63946');\n            } else if (p.type === 1) {\n                p5.fill('#457b9d');\n            } else if (p.type === 2) {\n                p5.fill('#2a9d8f');\n            } else {\n                p5.fill('#8d99ae');\n            }\n            \n            p5.circle(p.x, p.y, POINT_RADIUS);\n        });\n\n        //Visualize the cores\n        cores.forEach(core => {\n            if (core.type === 0) {\n                p5.fill('#e63946');\n            } else if (core.type === 1) {\n                p5.fill('#457b9d');\n            } else if (core.type === 2) {\n                p5.fill('#2a9d8f');\n            } else {\n                p5.fill('#8d99ae');\n            }\n            \n            p5.stroke('black');\n            p5.strokeWeight(5);\n            p5.circle(core.x, core.y, POINT_RADIUS * 1.5);\n        });\n\n        //Call update according to frame count\n        if (p5.frameCount % 15 === 0) {\n            update();\n        }\n        \n        //Draw panel\n        drawDisplayPanel(p5);\n    }\n\n    const drawDisplayPanel = (p5) => {\n        //Draw rectangle\n        p5.noStroke();\n        p5.fill(240);\n        p5.rect(width, 0, display, height);\n\n        //Display text\n        p5.fill(0);\n        p5.textSize(POINT_RADIUS);\n\n        //Display labels\n        p5.fill('#e63946')\n        p5.text('Red centroid', width + 20, 32);\n\n        p5.fill('#457b9d');\n        p5.text('Blue centriod', width + 20, 32 + POINT_RADIUS * 5);\n\n        p5.fill('#2a9d8f');\n        p5.text('Green centroid', width + 20, 32 + POINT_RADIUS * 10);\n\n        //Display position\n        p5.fill('black');\n        \n        //Red centroid\n        p5.text('x: ' + cores[0].x.toFixed(2).toString(), width + 40, 32 + POINT_RADIUS * 2);\n        p5.text('y: ' + cores[0].y.toFixed(2).toString(), width + 40, 32 + POINT_RADIUS * 3);\n\n        //Blue centroid\n        p5.text('x: ' + cores[1].x.toFixed(2).toString(), width + 40, 32 + POINT_RADIUS * 7);\n        p5.text('y: ' + cores[1].y.toFixed(2).toString(), width + 40, 32 + POINT_RADIUS * 8);\n\n        //Green centriod\n        p5.text('x: ' + cores[2].x.toFixed(2).toString(), width + 40, 32 + POINT_RADIUS * 12);\n        p5.text('y: ' + cores[2].y.toFixed(2).toString(), width + 40, 32 + POINT_RADIUS * 13);\n    }\n\n    return <div>\n        <Sketch\n            setup={setup}\n            draw={draw}\n            windowResized={windowResized}/>\n\n        <ControlPanel\n            onGenerateClusters={onGenerateClusters}\n            onGenerateCores={onGenerateCores}/>\n    </div>\n}","/Users/momocloud/Files/RMIT/BIT/app1/Machine-Learning-React-F/src/components/Algorithm/Sketches/linearregression/Wrapper.js",["235"],"import React, { useState } from 'react';\nimport Sketch from './LinearRegression';\n\nfunction Wrapper() {\n  return <div>\n    <Sketch/>\n  </div>\n}\n\nexport default Wrapper;","/Users/momocloud/Files/RMIT/BIT/app1/Machine-Learning-React-F/src/components/Algorithm/Sketches/logisticregression/LositicRegression.js",["236","237","238","239","240"],"import Sketch from 'react-p5';\nimport Model from './Model';\nimport Point from '../common/point';\nimport ControlPanel from './ControlPanel';\n\n//Save state outside components -> Need refractoring\n//Create model\nlet model = new Model();\n\n//Save losses\nlet losses = [];\nlet hasConverged = false;\n\n//List of points\nlet points = [];\n\n//List of segments for visualizing purpose\nconst SEG_SIZE = 10;\nlet segments = [];\n\nexport default (props) => {\n    //Current type of point\n    let currentType = 1;\n\n    const changeType = (type) => {\n        currentType = type;\n    }\n\n    const reset = () => {\n        points = [];\n        losses = [];\n        hasConverged = false;\n    }\n\n    //Train model and render result\n    const trainModel = () => {\n        //Convert points to x and y\n        let x = [];\n        let y = [];\n\n        points.forEach(p => {\n            x.push([p.x, p.y]);\n        });\n\n        points.forEach(p => {\n            y.push(p.type);\n        });\n\n        //Train model\n        return model.train(x, y);\n    }\n\n    const renderPredictions = (p5) => {\n        for (let i = 0; i != segments.length; ++i) {\n            //Get the segment location -> Map back to canvas\n            let x = p5.map(segments[i][0], 0, 1, 0, p5.width);\n            let y = p5.map(segments[i][1], 0, 1, p5.height, 0);\n            \n            //Get prob\n            let prob = model.predict([segments[i][0], segments[i][1]]);\n        \n            //Draw \n            if (prob > 0.5) {\n              p5.fill('rgba(69, 123, 157, ' + (prob/2).toString() + ')');\n            } else {\n              p5.fill('rgba(244, 162, 97, ' + ((1-prob)/2).toString() +')');\n            }\n            p5.noStroke();\n            p5.rect(x, y, SEG_SIZE, SEG_SIZE);\n        }\n    }\n\n    //Handle windows resize\n    const leftWindowResize = (p5) => {\n        let width = p5.windowWidth / 4, height = p5.windowWidth / 4;\n        p5.resizeCanvas(width, height);\n        initializeSegments(width, height, p5);\n    }\n\n    const rightWindowResize = (p5) => {\n        let width = p5.windowWidth / 4, height = p5.windowWidth / 4;\n        p5.resizeCanvas(width, height);\n    }\n\n    const leftSetup = (p5, canvasParentRef) => {\n        //Set canvas size\n        let width = p5.windowWidth / 4, height = p5.windowWidth / 4;\n        p5.createCanvas(width, height).parent(canvasParentRef);\n        initializeSegments(width, height, p5);\n    }\n\n    const initializeSegments = (width, height, p5) => {\n        segments = []; ///Reset\n        for (let r = 0; r != Math.round(width / SEG_SIZE); r++) {\n            for (let c = 0; c != Math.round(height / SEG_SIZE); ++c) {\n                //Map to [0, 1] interval\n                let x = p5.map(c * SEG_SIZE, 0, width, 0, 1);\n                let y = p5.map(r * SEG_SIZE, height, 0, 0, 1);\n                //Apppent to segments\n                segments.push([x, y]);\n            }\n        }\n    }\n\n    const leftDraw = (p5) => {\n        p5.background(204);\n\n        //Draw the existing points\n        p5.strokeWeight(1);\n        points.forEach(p => {\n            //Translate coordinates\n            let x = p5.map(p.x, 0, 1, 0, p5.width);\n            let y = p5.map(p.y, 0, 1, p5.height, 0);\n            \n            //Draw a circle\n            p5.noStroke();\n            if (p.type === 0) {\n                p5.fill('#F4A261');\n            } else if (p.type == 1) {\n                p5.fill('#457B9D');\n            }\n            \n            p5.circle(x, y, 10);\n        });\n\n        //Train model\n        if (points.length > 0 && !hasConverged) {\n            //Train model and get loss\n            losses.push(trainModel());\n\n            //Check if model has converged\n            if (losses.length >= 2 && Math.abs(losses[losses.length - 1] - losses[losses.length - 2]) <= 0.01) {\n                hasConverged = true;\n            }\n        }\n\n        //Show\n        if (losses.length > 0) {\n            renderPredictions(p5);\n        }\n    }\n\n    const leftMouseClicked = (p5) => {\n        //Check if mouse is in bound\n        if (p5.mouseX > 0 && p5.mouseX <= p5.width && p5.mouseY > 0 && p5.mouseY <= p5.height) {\n            //Create a point\n            let x = p5.map(p5.mouseX, 0, p5.width, 0, 1);\n            let y = p5.map(p5.mouseY, 0, p5.height, 1, 0);\n\n            //Append to list of points\n            points.push(new Point(x, y, currentType));\n\n            //Dismissed hasConverged and losses\n            hasConverged = false;\n            losses = [];\n        }\n    }\n\n    //Draw loss\n    const rightSetup = (p5, canvasParentRef) => {\n        p5.createCanvas(p5.windowWidth / 4, p5.windowWidth / 4).parent(canvasParentRef);\n    }\n\n    const rightDraw = (p5) => {\n        p5.background(255);\n\n        if (losses.length > 0) {\n            drawLosses(p5);\n        }\n    }\n\n    const drawLosses = (p5) => {\n        p5.stroke('#457B9D');\n\n        //Calculate the current x offset\n        let offset = 40;\n        let offSetChange = (p5.width - offset * 2) / (losses.length);\n\n        //Get the latest loss -> Display\n        p5.textSize(20);\n        p5.fill('#457B9D');\n        p5.strokeWeight(1);\n        p5.textFont('Raleway');\n        p5.text('Loss: ' + losses[losses.length - 1].toFixed(4).toString(), 40, 20);\n\n        //Check if converge\n        if (hasConverged) {\n            p5.fill('#2a9d8f');\n            p5.noStroke();\n            p5.textFont('Raleway');\n            p5.text('Converged', 40, 40);\n        }\n\n        //Draw line chart showing plots\n        p5.noFill();\n        p5.stroke('#457B9D');\n        p5.strokeWeight(3);\n        p5.beginShape();\n\n        losses.forEach((loss) => {\n            //Map the loss\n            let mappedLoss;\n            mappedLoss = p5.map(loss, 0, losses[0], p5.height, p5.width / 2);\n\n            //Draw vertex \n            p5.vertex(offset, mappedLoss);\n\n            //Increase offset\n            offset += offSetChange;\n        })\n\n        p5.endShape();\n    }\n\n    return <div>\n        <div style={{float: \"left\"}}>\n            <Sketch \n                setup={leftSetup} \n                draw={leftDraw}\n                mouseClicked={leftMouseClicked}\n                windowResized={leftWindowResize}>\n            </Sketch>\n        </div>\n\n        <div style={{float: \"left\"}}>\n            <Sketch \n                setup={rightSetup} \n                draw={rightDraw}\n                windowResized={rightWindowResize}>\n            </Sketch>\n        </div>\n\n        <div style={{clear: \"both\"}}></div>\n        \n        <ControlPanel\n            onChangeType={(type) => changeType(type)}\n            onReset={() => reset()}\n        />\n    </div>\n}","/Users/momocloud/Files/RMIT/BIT/app1/Machine-Learning-React-F/src/components/Algorithm/Sketches/nearestneighbors/NearestNeighbor.js",["241","242","243"],"import { StaticPoint, DynamicPoint } from './point';\nimport Sketch from 'react-p5';\nimport ControlPanel from './ControlPanel';\n\n//Save state outside components -> Need to rethink\nlet staticPoints = [];\nlet neighbors = 5;\nlet neighborCounts;\n\n//Core points to cluster around\nlet corePoints = [];\n\n//Create user-controlled point\nlet dynamicPoint = new DynamicPoint(-100, -100);\n\n//Sizes\nlet width, height, display;\n\n//Create holder for points\nlet POINT_RADIUS = 15;\n\n//Hold ref to p5 for math functionality\nlet p5Ref;\n\nexport default (props) => {\n    //Function to draw a point\n    const drawPoint = (p5, p) => {\n        p5.stroke('black');\n        if (p.type === 0) {\n            p5.fill('#e63946');\n        } else if (p.type === 1) {\n            p5.fill('#457b9d');\n        } else if (p.type === 2) {\n            p5.fill('#2a9d8f');\n        } else {\n            p5.fill('#8d99ae');\n        }\n        p5.circle(p.x, p.y, POINT_RADIUS);\n    }\n\n    //Function to draw display panel\n    const translateClass = (name) => {\n        if (name === 0) {\n            return \"Red\";\n        } else if (name === 1){\n            return \"Blue\";\n        } else if (name === 2) {\n            return \"Green\";\n        } else {\n            return \"Not found\";\n        }\n    }\n\n    const drawDisplayPanel = (p5) => {\n        //Use white background color\n        p5.fill(240);\n        p5.noStroke();\n        p5.rect(width, 0, display, height);\n\n        //Write text\n        p5.fill(0);\n        p5.textSize(POINT_RADIUS);\n\n        //Draw number of neighbors\n        p5.text('K: ' + neighbors.toString(), width + 20, 32)\n\n        //Draw chosen class\n        p5.text('Class: ', width + 20, 64);\n        if (dynamicPoint.type === 0) {\n            p5.fill('#e63946');\n        } else if (dynamicPoint.type === 1) {\n            p5.fill('#457b9d');\n        } else if (dynamicPoint.type === 2) {\n            p5.fill('#2a9d8f');\n        } else {\n            p5.fill('#8d99ae');\n        }\n        p5.text(translateClass(dynamicPoint.type), width + 20 + POINT_RADIUS * 3, 64);\n\n        //Draw neighbors count\n        p5.fill(0);\n        p5.text('Red neighbors: ', width + 20, 96);\n        p5.text('Blue neighbors: ', width + 20, 128);\n        p5.text('Green neighbors: ', width + 20, 160);\n\n        p5.fill('#e63946');\n        p5.text((neighborCounts ? neighborCounts[0].toString() : \"0\"), width + 20 + POINT_RADIUS * 8, 96);\n        p5.fill('#457b9d');\n        p5.text((neighborCounts ? neighborCounts[1].toString() : \"0\"), width + 20 + POINT_RADIUS * 8, 128);\n        p5.fill('#2a9d8f');\n        p5.text((neighborCounts ? neighborCounts[2].toString() : \"0\"), width + 20 + POINT_RADIUS * 8, 160);\n    }\n\n    //Function to generate static points around cores\n    const generateStaticPoints = () => {\n        //Clear existing\n        staticPoints = [...corePoints];\n        \n        //Populate static points using random data\n        corePoints.forEach(core => {\n            //Create about 10 data points for each core points\n            for (let i = 0; i != 30; ++i) {\n                //Create points\n                let x = core.x + p5Ref.randomGaussian(0, 50);\n                let y = core.y + p5Ref.randomGaussian(0, 50);\n\n                //Check in boud\n                while (!(x >= POINT_RADIUS && x < width - POINT_RADIUS && y >= POINT_RADIUS && y < height - POINT_RADIUS)) {\n                    x = core.x + p5Ref.randomGaussian(0, 50);\n                    y = core.y + p5Ref.randomGaussian(0, 50);\n                }\n\n                //Add points\n                staticPoints.push(new StaticPoint(x, y, core.type));\n            }\n        });\n    }\n\n    const scalePoints = (ratio) => {\n        staticPoints.forEach(point => {\n            point.x = point.x * ratio;\n            point.y = point.y * ratio;\n        });\n    }\n\n    //Function to find neighbors for the dynamic points\n    const findNeighbors = (total) => {\n        //map coordinates to [0, 1] interval\n        let uX = dynamicPoint.x\n        let uY = dynamicPoint.y\n        \n        staticPoints.forEach(sPoint => {\n            //map coordinates to [0, 1] interval\n            let sX = sPoint.x\n            let sY = sPoint.y\n            \n            //Calculate the eucleadian distance and add to list\n            sPoint.setDistance(Math.sqrt(Math.pow(uX - sX, 2) + Math.pow(uY - sY, 2)));\n        });\n        \n        //Sort to ascending order\n        let copiedPoints = staticPoints.slice();\n        copiedPoints.sort((a, b) => a.distanceToUser - b.distanceToUser);\n        \n        //Get closest neighbors\n        dynamicPoint.setNeighbors(copiedPoints.slice(0, total));\n    }\n\n    const findType = () => {\n        //Count neighbor type\n        let typeCounts = {\n            0: 0,\n            1: 0,\n            2: 0\n        }\n        \n        dynamicPoint.neighbors.forEach(p => {\n            typeCounts[p.type] += 1;\n        });\n\n        //Save neighbor counts\n        neighborCounts = typeCounts;\n        \n        //Get the type with highest count\n        let maxType = 0;\n        let maxCount = -1;\n        for (let i = 0; i != 3; ++i) {\n            if (typeCounts[i] > maxCount) {\n                maxType = i;\n                maxCount = typeCounts[i];\n            }\n        }\n        \n        dynamicPoint.setType(maxType);\n    }\n\n    //Handle user interaction\n    const onRegenerate = () => {\n        generateStaticPoints();\n        //Remove neighbors\n        dynamicPoint.neighbors = [];\n        dynamicPoint.type = null;\n    }\n\n    const onSetNeighbors = (totalNeighbors) => {\n        neighbors = parseInt(totalNeighbors);\n    }\n\n    //Handle resize\n    const windowResized = (p5) => {\n        //Get the new size\n        let newWidth = p5.windowWidth / 3;\n        let newHeight = p5.windowWidth / 3;\n        let newDisplay = p5.windowWidth / 6;\n\n        //Get the ratio\n        let ratio = newWidth / width;\n        POINT_RADIUS *= ratio;\n        scalePoints(ratio);\n\n        //Set new sizes\n        width = newWidth;\n        height = newHeight;\n        display = newDisplay\n\n        //Resize the canvas\n        p5.resizeCanvas(width + display, height);\n    }\n\n    //Set up and draw function for left canvas\n    const leftSetup = (p5, canvasParentRef) => {\n        //Create windows\n        width = p5.windowWidth / 3;\n        height = p5.windowWidth / 3;\n        display = p5.windowWidth / 6;\n        p5.createCanvas(width + display, height).parent(canvasParentRef);\n\n        //Set point radius\n        POINT_RADIUS = width / 30;\n\n        //Create cores\n        corePoints = [\n            new StaticPoint(width * 0.25, height * 0.3, 0),\n            new StaticPoint(width * 0.75, height * 0.3, 1),\n            new StaticPoint(width * 0.5, height * 0.75, 2)\n        ];\n\n        //Save reference to p5 library\n        p5Ref = p5;\n        p5.textFont('Raleway');\n\n        generateStaticPoints();\n    }\n\n    const leftDraw = (p5) => {\n        //Background\n        p5.background(204);\n\n        //Draw display panel\n        drawDisplayPanel(p5);\n\n        //Highlighting the user point's neighbors\n        dynamicPoint.neighbors.forEach(neighbor => {\n            //Draw line\n            p5.stroke('black');\n            p5.strokeWeight(2);\n            p5.line(dynamicPoint.x, dynamicPoint.y, neighbor.x, neighbor.y);\n            \n            //Highlight neigbors\n            p5.noFill();\n            p5.stroke('yellow');\n            p5.circle(neighbor.x, neighbor.y, POINT_RADIUS + 4);\n        });\n\n        //Draw points\n        p5.strokeWeight(2);\n\n        corePoints.forEach(p => {\n            drawPoint(p5, p);\n        });\n\n        staticPoints.forEach(p => {\n            drawPoint(p5, p);\n        });\n        \n        drawPoint(p5, dynamicPoint, '#16b8f3');\n    }\n\n    const leftMouseMove = (p5) => {\n        //Check if mouse is in bound\n        if (p5.mouseX >= 0 && p5.mouseX <= p5.width - display && p5.mouseY >= 0 && p5.mouseY <= p5.height) {\n            //Set new location for points\n            dynamicPoint.setLocation(p5.mouseX, p5.mouseY);\n            \n            //Set new nearest neighbors for userpoint\n            findNeighbors(neighbors);\n            \n            //Set new type for userpoints\n            findType();\n        }\n    }\n\n    return <div>\n        <Sketch \n            setup={leftSetup}\n            draw={leftDraw}\n            mouseMoved={leftMouseMove}\n            windowResized={windowResized}>\n        </Sketch>\n\n        <ControlPanel\n            onRegenerate={onRegenerate}\n            onSetNeighbors={onSetNeighbors}/>\n    </div>\n}","/Users/momocloud/Files/RMIT/BIT/app1/Machine-Learning-React-F/src/components/Home/ThirdSegment/ConvNetCard.js",[],"/Users/momocloud/Files/RMIT/BIT/app1/Machine-Learning-React-F/src/components/Home/ThirdSegment/P5Card.js",[],"/Users/momocloud/Files/RMIT/BIT/app1/Machine-Learning-React-F/src/components/Home/ThirdSegment/TensorflowCard.js",[],"/Users/momocloud/Files/RMIT/BIT/app1/Machine-Learning-React-F/src/components/Home/SecondSegment/AlgorithmCarousel.js",[],"/Users/momocloud/Files/RMIT/BIT/app1/Machine-Learning-React-F/src/components/Algorithm/Sketches/neuralnetwork/ControlPanel.js",["244"],"import React, { useState } from 'react';\nimport StartStopButton from './StartStopButton';\n\nexport default (props) => {\n    const [type, setType] = useState(1);\n\n    //Call parent methods\n    const changeType = (type) => {\n        props.onChangeType(type);\n        //Rerender\n        setType(type);\n    }\n\n    const start = () => {\n        props.onStart();\n    }\n\n    const stop = () => {\n        props.onStop();\n    }\n\n    const reset = () => {\n        props.onReset();\n    }\n\n    return <div>\n            <div className=\"columns\" style={{width: \"80%\", margin: \"auto\", marginBottom: \"0.5em\", textAlign: \"center\"}}>\n                <div className=\"column\" style={{textAlign: \"center\"}}>\n                    <div\n                        className={type === 1 ? \"positive-chosen\" : \"positive\"}\n                        onClick={() => changeType(1)}>\n                    </div>\n                </div>\n                \n                <div className=\"column\" style={{textAlign: \"center\"}}>\n                    <div\n                        className={type === 0 ? \"negative-chosen\" : \"negative\"}\n                        onClick={() => { changeType(0) }}>\n                    </div>\n                </div>\n\n                <div className=\"column\">\n                    <button\n                        className=\"button\"\n                        style={{width: \"50%\", background: \"#f9dcc4\", fontSize: \"1.2vw\"}}\n                        onClick={reset}>\n                        Clear all\n                    </button>\n                </div>\n            </div>\n\n        <StartStopButton\n            color=\"#f9dcc4\"\n            start={start}\n            stop={stop}/>\n    </div>\n}","/Users/momocloud/Files/RMIT/BIT/app1/Machine-Learning-React-F/src/components/Algorithm/Sketches/kmeanclustering/cluster.js",[],"/Users/momocloud/Files/RMIT/BIT/app1/Machine-Learning-React-F/src/components/Algorithm/Sketches/logisticregression/Model.js",["245","246"],"import convnetjs from 'convnetjs';\n\nexport default class Model {\n    constructor() {\n      this.createModel();\n    }\n    \n    createModel() {\n      //Create layer definition\n      let layer_defs = [\n        {\n          type: 'input',\n          out_sx: 1,\n          out_sy: 1,\n          out_depth: 2\n        },\n        {\n          type: 'softmax',\n          num_classes: 2\n        }\n      ];\n      \n      //Create model\n      this.model = new convnetjs.Net();\n      this.model.makeLayers(layer_defs);\n      \n      //Create input placeholder\n      this.input = new convnetjs.Vol(1, 1, 2);\n      \n      //Create trainer\n      this.trainer = new convnetjs.Trainer(\n        this.model,\n        {\n          method: 'sgd', \n          learning_rate: 0.01, \n          l2_decay: 0.001, \n          momentum: 0.9, \n          batch_size: 10\n        }\n      );\n    }\n    \n    train(inputs, labels) {\n      //Save the loss\n      let loss = 0;\n      \n      //Train for 20 iterations\n      for(let i = 0; i != 20; ++i) {\n        for (let j = 0; j != inputs.length; ++j) {\n          //Set input\n          this.input.w[0] = inputs[j][0];\n          this.input.w[1] = inputs[j][1];\n          \n          //Train -> Get loss\n          let result = this.trainer.train(this.input, labels[j]);\n          \n          //Add \n          loss += result.loss;\n        }\n      }\n      \n      //Get average loss\n      return loss / inputs.length;\n    }\n    \n    predict(x) {\n      //Set data\n      this.input.w[0] = x[0];\n      this.input.w[1] = x[1];\n      \n      //Run through model\n      let result = this.model.forward(this.input, false);\n      \n      //Convert to number\n      return result.w[1];\n    }\n  }","/Users/momocloud/Files/RMIT/BIT/app1/Machine-Learning-React-F/src/components/Algorithm/Sketches/logisticregression/ControlPanel.js",["247"],"import React, { useState } from 'react';\n\nexport default (props) => {\n    //Initialize the state\n    const [type, setType] = useState(1);\n\n    //Call parent methods\n    const changeType = (type) => {\n        props.onChangeType(type);\n        //Rerender\n        setType(type);\n    }\n\n    //Render\n    return <div className=\"columns\" style={{width: \"80%\", margin: \"auto\"}}>\n        <div className=\"column\" style={{textAlign: \"center\"}}>\n            <div\n                className={type === 1 ? \"positive-chosen\" : \"positive\"}\n                onClick={() => changeType(1)}>\n            </div>\n        </div>\n        \n        <div className=\"column\" style={{textAlign: \"center\"}}>\n            <div\n                className={type === 0 ? \"negative-chosen\" : \"negative\"}\n                onClick={() => { changeType(0) }}>\n            </div>\n        </div>\n\n        <div className=\"column\">\n            <button\n                className=\"button\"\n                style={{width: \"50%\", background: \"#90e0ef\", fontSize: \"1.2vw\"}}\n                onClick={() => props.onReset()}>\n                Clear all\n            </button>\n        </div>\n    </div>\n}","/Users/momocloud/Files/RMIT/BIT/app1/Machine-Learning-React-F/src/components/Algorithm/Sketches/linearregression/LinearRegression.js",["248","249"],"import Model from './Model';\nimport Sketch from 'react-p5';\n\n//Store the data outside react component -> Not recommend\nlet inputs = [];\nlet outputs = [];\n\n//Linear model\nlet model = new Model();\n\n//Save model losses\nlet losses = [];\nlet hasConverged = false;\n\nexport default (props) => {\n    //Method for reseting sketch\n    const reset = () => {\n        model = new Model();\n        inputs = [];\n        outputs = [];\n        losses = [];\n        hasConverged = false;\n    }\n\n    //Method to handle windows resize\n    const windowResize = (p5) => {\n        p5.resizeCanvas(p5.windowWidth / 4, p5.windowWidth / 4);\n    }\n\n    //Methods for left canvas\n    const leftSetup = (p5, canvasParentRef) => {\n        p5.createCanvas(p5.windowWidth / 4, p5.windowWidth / 4).parent(canvasParentRef);\n    };\n\n    const leftDraw = (p5) => {\n        //Draw background\n        p5.background('black');\n\n        //Display appended points in arrays\n        p5.fill('#ffd7b5');\n        p5.stroke('white');\n        p5.strokeWeight(2);\n        for (let i = 0; i != inputs.length; ++i) {\n            let px = p5.map(inputs[i], 0, 1, 0, p5.width);\n            let py = p5.map(outputs[i], 0, 1, p5.height, 0);\n            p5.circle(px, py, 20);\n        }\n        \n        //Train network\n        if (inputs.length > 0 && !hasConverged) {\n            let loss = model.train(inputs, outputs);\n            losses.push(loss[0]);\n        }\n\n        //Check if model has converged\n        if (losses.length >= 2 && Math.abs(losses[losses.length - 1] - losses[losses.length - 2]) < 0.0000001) {\n            hasConverged = true;\n        }\n\n        //Draw regression line\n        drawRegressionLine(p5);\n    };\n\n    const drawRegressionLine = (p5) => {\n        //Get points and predictions\n        let points = [0, 1];\n        let predictions = model.predict(points);\n\n        //Map to canvas dimension\n        points = points.map(val => p5.map(val, 0, 1, 0, p5.width));\n        predictions = predictions.map(val => p5.map(val, 0, 1, p5.height, 0));\n\n        //Draw line\n        p5.strokeWeight(3);\n        p5.stroke('#ff9248');\n        p5.line(points[0], predictions[0], points[1], predictions[1])\n    }\n\n    const leftMouseClicked = (p5) => {\n        if (p5.mouseX > 0 && p5.mouseX <= p5.width && p5.mouseY > 0 && p5.mouseY <= p5.height) {\n            //Reset model\n            //model.reset();\n            hasConverged = false;\n\n            //Add new points\n            let x = p5.map(p5.mouseX, 0, p5.width, 0, 1);\n            let y = p5.map(p5.mouseY, 0, p5.height, 1, 0);\n\n            //Add to input\n            inputs.push(x);\n            outputs.push(y);\n\n            //Reset loss\n            losses = [];\n        }\n    }\n\n    //Method for right canvas\n    const rightSetup = (p5, canvasParentRef) => {\n        p5.createCanvas(p5.windowWidth / 4, p5.windowWidth / 4).parent(canvasParentRef);\n        p5.noStroke();\n    }\n\n    const rightDraw = (p5) => {\n        p5.background('white');\n        \n        //Draw the line loss plot\n        if (losses.length > 0) {\n            drawLosses(p5);\n        }\n    }\n\n    const drawLosses = (p5) => {\n        //Calculate the current x offset\n        let offset = 40;\n        let offSetChange = (p5.width - offset * 2) / (losses.length);\n\n        //Get the latest loss -> Display\n        p5.textSize(20);\n        p5.fill('#ddbea9');\n        p5.strokeWeight(1);\n        p5.textFont('Raleway');\n        p5.text('Loss: ' + losses[losses.length - 1].toFixed(4).toString(), 40, 20);\n\n        //Check if converge\n        if (hasConverged) {\n            p5.fill('#2a9d8f');\n            p5.noStroke();\n            p5.textFont('Raleway');\n            p5.text('Converged', 40, 40);\n        }\n\n        //Draw line chart showing plots\n        p5.noFill();\n        p5.stroke('#ddbea9');\n        p5.strokeWeight(2);\n        p5.beginShape();\n\n        losses.forEach((loss) => {\n            //Map the loss\n            let mappedLoss;\n            mappedLoss = p5.map(loss, 0, losses[0], p5.height, p5.width / 2);\n\n            //Draw vertex \n            p5.vertex(offset, mappedLoss);\n            //Increase offset\n            offset += offSetChange;\n        })\n\n        p5.endShape();\n    }\n\n    return <div>\n        <div style={{float: \"left\"}}>\n            <Sketch \n                setup={leftSetup} \n                draw={leftDraw}\n                mouseClicked={leftMouseClicked}\n                windowResized={windowResize}>\n            </Sketch>\n        </div>\n\n        <div style={{float: \"left\"}}>\n            <Sketch \n                setup={rightSetup} \n                draw={rightDraw}\n                windowResized={windowResize}>\n            </Sketch>\n        </div>\n\n        <div style={{clear: \"both\"}}></div>\n        <button \n            onClick={() => reset()} \n            className=\"button is-primary\" \n            style={{width: \"100%\", background: \"#F1FAEE\", color: \"black\"}}>\n            Reset\n        </button>\n    </div>\n}","/Users/momocloud/Files/RMIT/BIT/app1/Machine-Learning-React-F/src/components/Algorithm/Sketches/nearestneighbors/point.js",[],"/Users/momocloud/Files/RMIT/BIT/app1/Machine-Learning-React-F/src/components/Algorithm/Sketches/nearestneighbors/ControlPanel.js",["250"],"export default (props) => {\n    const onRegenerate = () => {\n        props.onRegenerate();\n    }\n\n    const onNeighborSubmit = (event) => {\n        event.preventDefault();\n        props.onSetNeighbors(event.target.neighbors.value);\n    }\n\n    return <div className=\"columns\">\n        <div className=\"column is-three-fifths\">\n            <form \n                noValidate \n                autoComplete=\"off\" \n                onSubmit={onNeighborSubmit}\n                style={{width: \"100%\"}}>\n                    <div className=\"field has-addons\">\n                        <div className=\"control\">\n                            <input \n                                type=\"text\"\n                                name=\"neighbors\" \n                                placeholder=\"Enter the number of neighbors (K)\"\n                                className=\"input\"\n                                style={{fontSize: \"1.2vw\"}}/>\n                        </div>\n                        <div className=\"control\" style={{width: \"50%\"}}>\n                            <button\n                                className=\"button is-primary\"\n                                style={{width: \"100%\", background: \"#b7e4c7\", fontSize: \"1.2vw\"}}>\n                                Set neighbors\n                            </button>\n                        </div>\n                    </div>\n            </form>\n        </div>\n\n        <div className=\"column is-two-fifths\">\n            <button\n                className=\"button\"\n                style={{width: \"100%\", background: \"#52b788\", color: \"white\", fontSize: \"1.2vw\"}}\n                onClick={onRegenerate}>\n                    Regenerate cores\n            </button>\n        </div>\n    </div>\n}","/Users/momocloud/Files/RMIT/BIT/app1/Machine-Learning-React-F/src/components/Algorithm/Sketches/neuralnetwork/Model.js",["251","252"],"import convnetjs from 'convnetjs';\n\nexport default class Model {\n    constructor() {\n        this.createModel();\n    }\n\n    createModel() {\n        //Create layer def\n        let layer_definitions = [];\n\n        //Add layer\n        layer_definitions.push({\n            type: 'input',\n            out_sx: 1,\n            out_sy: 1,\n            out_depth: 2\n        });\n\n        layer_definitions.push({\n            type: 'fc',\n            num_neurons: 6,\n            activation: 'tanh'\n        });\n\n        layer_definitions.push({\n            type: 'fc',\n            num_neurons: 2,\n            activation: 'tanh'\n        });\n\n        layer_definitions.push({\n            type: 'softmax',\n            num_classes: 2\n        });\n\n        //Create network\n        this.model = new convnetjs.Net();\n        this.model.makeLayers(layer_definitions);\n\n        //Create trainner\n        this.trainer = new convnetjs.SGDTrainer(\n            this.model, {\n                learning_rate: 0.001,\n                mometum: 0.9,\n                batch_size: 10,\n                l2_decay: 0.001\n            }\n        );\n\n        //Create input\n        this.input = new convnetjs.Vol(1, 1, 2);\n    }\n\n    train(inputs, labels) {\n        let loss = 0;\n\n        for (let j = 0; j != 20; ++j) {\n            for (let i = 0; i != inputs.length; ++i) {\n                //Set data\n                this.input.w = inputs[i];\n\n                //Train\n                let result = this.trainer.train(this.input, labels[i]);\n\n                //Add loss\n                loss += result.loss;\n            }\n        }\n\n        //Average loss\n        return loss / inputs.length;\n    }\n\n    predict(input) {\n        //Set input\n        this.input.w = input;\n\n        //Get output\n        let result = this.model.forward(this.input, false);\n\n        //Softmax layer result\n        return result.w[1];\n    }\n}","/Users/momocloud/Files/RMIT/BIT/app1/Machine-Learning-React-F/src/components/Algorithm/Sketches/kmeanclustering/ControlPanel.js",["253"],"export default (props) => {\n    return <div>\n        <button\n            className=\"button\"\n            onClick={() => props.onGenerateClusters()}\n            style={{width: \"100%\", background: \"#ecbcfd\", color: \"white\"}}>\n            Generate clusters\n        </button><br/>\n\n        <button\n            className=\"button is-info\"\n            onClick={() => props.onGenerateCores()}\n            style={{width: \"100%\", background: \"#ffafcc\", color: \"white\"}}>\n            Restart\n        </button>\n    </div>\n}","/Users/momocloud/Files/RMIT/BIT/app1/Machine-Learning-React-F/src/components/Algorithm/Sketches/common/point.js",[],"/Users/momocloud/Files/RMIT/BIT/app1/Machine-Learning-React-F/src/components/Home/SecondSegment/LogisticRegressionCard.js",[],"/Users/momocloud/Files/RMIT/BIT/app1/Machine-Learning-React-F/src/components/Home/SecondSegment/LinearRegressionCard.js",[],"/Users/momocloud/Files/RMIT/BIT/app1/Machine-Learning-React-F/src/components/Home/SecondSegment/NeuralNetworkCard.js",[],"/Users/momocloud/Files/RMIT/BIT/app1/Machine-Learning-React-F/src/components/Home/SecondSegment/ObjectDetectionCard.js",[],"/Users/momocloud/Files/RMIT/BIT/app1/Machine-Learning-React-F/src/components/Home/SecondSegment/KMeanCard.js",[],"/Users/momocloud/Files/RMIT/BIT/app1/Machine-Learning-React-F/src/components/Home/SecondSegment/KNearestNeighborsCard.js",[],"/Users/momocloud/Files/RMIT/BIT/app1/Machine-Learning-React-F/src/components/Algorithm/Sketches/neuralnetwork/StartStopButton.js",[],"/Users/momocloud/Files/RMIT/BIT/app1/Machine-Learning-React-F/src/components/Algorithm/Sketches/linearregression/Model.js",[],"/Users/momocloud/Files/RMIT/BIT/app1/Machine-Learning-React-F/src/components/Home/FirstSegment/Sketch.js",[],{"ruleId":"254","severity":1,"message":"255","line":9,"column":3,"nodeType":"256","messageId":"257","endLine":9,"endColumn":7},{"ruleId":"258","replacedBy":"259"},{"ruleId":"260","replacedBy":"261"},{"ruleId":"254","severity":1,"message":"262","line":1,"column":20,"nodeType":"256","messageId":"257","endLine":1,"endColumn":26},{"ruleId":"254","severity":1,"message":"263","line":3,"column":8,"nodeType":"256","messageId":"257","endLine":3,"endColumn":14},{"ruleId":"264","severity":1,"message":"265","line":26,"column":9,"nodeType":"266","messageId":"267","endLine":26,"endColumn":86},{"ruleId":"254","severity":1,"message":"268","line":1,"column":8,"nodeType":"256","messageId":"257","endLine":1,"endColumn":13},{"ruleId":"254","severity":1,"message":"269","line":2,"column":8,"nodeType":"256","messageId":"257","endLine":2,"endColumn":12},{"ruleId":"254","severity":1,"message":"255","line":5,"column":9,"nodeType":"256","messageId":"257","endLine":5,"endColumn":13},{"ruleId":"254","severity":1,"message":"270","line":2,"column":8,"nodeType":"256","messageId":"257","endLine":2,"endColumn":13},{"ruleId":"271","severity":1,"message":"272","line":30,"column":1,"nodeType":"273","endLine":255,"endColumn":2},{"ruleId":"274","severity":1,"message":"275","line":53,"column":27,"nodeType":"276","messageId":"277","endLine":53,"endColumn":29},{"ruleId":"274","severity":1,"message":"275","line":54,"column":31,"nodeType":"276","messageId":"277","endLine":54,"endColumn":33},{"ruleId":"274","severity":1,"message":"275","line":81,"column":27,"nodeType":"276","messageId":"277","endLine":81,"endColumn":29},{"ruleId":"274","severity":1,"message":"278","line":126,"column":24,"nodeType":"276","messageId":"277","endLine":126,"endColumn":26},{"ruleId":"271","severity":1,"message":"272","line":25,"column":1,"nodeType":"273","endLine":282,"endColumn":2},{"ruleId":"274","severity":1,"message":"275","line":34,"column":31,"nodeType":"276","messageId":"277","endLine":34,"endColumn":33},{"ruleId":"274","severity":1,"message":"275","line":53,"column":27,"nodeType":"276","messageId":"277","endLine":53,"endColumn":29},{"ruleId":"274","severity":1,"message":"275","line":107,"column":38,"nodeType":"276","messageId":"277","endLine":107,"endColumn":40},{"ruleId":"254","severity":1,"message":"279","line":1,"column":17,"nodeType":"256","messageId":"257","endLine":1,"endColumn":25},{"ruleId":"271","severity":1,"message":"272","line":21,"column":1,"nodeType":"273","endLine":240,"endColumn":2},{"ruleId":"274","severity":1,"message":"275","line":54,"column":27,"nodeType":"276","messageId":"277","endLine":54,"endColumn":29},{"ruleId":"274","severity":1,"message":"275","line":94,"column":27,"nodeType":"276","messageId":"277","endLine":94,"endColumn":29},{"ruleId":"274","severity":1,"message":"275","line":95,"column":31,"nodeType":"276","messageId":"277","endLine":95,"endColumn":33},{"ruleId":"274","severity":1,"message":"278","line":119,"column":31,"nodeType":"276","messageId":"277","endLine":119,"endColumn":33},{"ruleId":"271","severity":1,"message":"272","line":25,"column":1,"nodeType":"273","endLine":295,"endColumn":2},{"ruleId":"274","severity":1,"message":"275","line":102,"column":31,"nodeType":"276","messageId":"277","endLine":102,"endColumn":33},{"ruleId":"274","severity":1,"message":"275","line":167,"column":27,"nodeType":"276","messageId":"277","endLine":167,"endColumn":29},{"ruleId":"271","severity":1,"message":"272","line":4,"column":1,"nodeType":"273","endLine":57,"endColumn":2},{"ruleId":"274","severity":1,"message":"275","line":48,"column":24,"nodeType":"276","messageId":"277","endLine":48,"endColumn":26},{"ruleId":"274","severity":1,"message":"275","line":49,"column":27,"nodeType":"276","messageId":"277","endLine":49,"endColumn":29},{"ruleId":"271","severity":1,"message":"272","line":3,"column":1,"nodeType":"273","endLine":39,"endColumn":2},{"ruleId":"271","severity":1,"message":"272","line":15,"column":1,"nodeType":"273","endLine":179,"endColumn":2},{"ruleId":"274","severity":1,"message":"275","line":43,"column":27,"nodeType":"276","messageId":"277","endLine":43,"endColumn":29},{"ruleId":"271","severity":1,"message":"272","line":1,"column":1,"nodeType":"273","endLine":47,"endColumn":2},{"ruleId":"274","severity":1,"message":"275","line":58,"column":27,"nodeType":"276","messageId":"277","endLine":58,"endColumn":29},{"ruleId":"274","severity":1,"message":"275","line":59,"column":31,"nodeType":"276","messageId":"277","endLine":59,"endColumn":33},{"ruleId":"271","severity":1,"message":"272","line":1,"column":1,"nodeType":"273","endLine":17,"endColumn":2},"no-unused-vars","'Link' is defined but never used.","Identifier","unusedVar","no-native-reassign",["280"],"no-negated-in-lhs",["281"],"'useRef' is defined but never used.","'Navbar' is defined but never used.","no-lone-blocks","Nested block is redundant.","BlockStatement","redundantNestedBlock","'React' is defined but never used.","'logo' is defined but never used.","'Panel' is defined but never used.","import/no-anonymous-default-export","Assign arrow function to a variable before exporting as module default","ExportDefaultDeclaration","eqeqeq","Expected '!==' and instead saw '!='.","BinaryExpression","unexpected","Expected '===' and instead saw '=='.","'useState' is defined but never used.","no-global-assign","no-unsafe-negation"]